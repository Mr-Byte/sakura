//! Code generated by `cargo xtask codegen`; DO NOT EDIT.

#![allow(
    dead_code,
    bad_style,
    missing_docs,
    unreachable_pub,
    clippy::manual_non_exhaustive,
    clippy::upper_case_acronyms
)]
#[non_exhaustive]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(u16)]
pub enum SyntaxKind {
    #[doc(hidden)]
    TOMBSTONE,
    #[doc(hidden)]
    EOF,
    LEFT_PAREN,
    RIGHT_PAREN,
    LEFT_CURLY,
    RIGHT_CURLY,
    LEFT_BRACKET,
    RIGHT_BRACKET,
    COMMA,
    DOT,
    COLON,
    SEMICOLON,
    EQUAL,
    PLUS,
    MINUS,
    STAR,
    SLASH,
    AMPERSAND,
    PIPE,
    CARET,
    TILDE,
    PERCENT,
    AT,
    HASH,
    BANG,
    QUESTION,
    DOLLAR,
    UNDERSCORE,
    DOUBLE_STAR,
    DOUBLE_DOT,
    DOUBLE_DOT_EQUAL,
    DOUBLE_EQUAL,
    DOUBLE_AMPERSAND,
    DOUBLE_PIPE,
    FAT_ARROW,
    NOT_EQUAL,
    LESS_THAN,
    GREATER_THAN,
    LESS_THAN_EQUAL,
    GREATER_THAN_EQUAL,
    PLUS_EQUAL,
    MINUS_EQUAL,
    PIPE_EQUAL,
    AMPERSAND_EQUAL,
    CARET_EQUAL,
    SLASH_EQUAL,
    STAR_EQUAL,
    PERCENT_EQUAL,
    SHIFT_LEFT,
    SHIFT_RIGHT,
    SHIFT_LEFT_EQUAL,
    SHIFT_RIGHT_EQUAL,
    TYPE_KW,
    STRUCT_KW,
    ENUM_KW,
    UNION_KW,
    TRAIT_KW,
    FN_KW,
    TEST_KW,
    VAL_KW,
    VAR_KW,
    CONST_KW,
    USING_KW,
    EXTEND_KW,
    IMPORT_KW,
    EXPORT_KW,
    TRUE_KW,
    FALSE_KW,
    WHERE_KW,
    BOX_KW,
    REF_KW,
    IF_KW,
    ELSE_KW,
    WHILE_KW,
    LOOP_KW,
    FOR_KW,
    DELEGATE_KW,
    INT_LITERAL,
    FLOAT_LITERAL,
    CHAR_LITERAL,
    BYTE_LITERAL,
    STRING_LITERAL,
    STRING_LITERAL_FRAGMENT,
    ERROR,
    IDENTIFIER,
    WHITESPACE,
    LINE_COMMENT,
    BLOCK_COMMENT,
    INT_LITERAL_PREFIX,
    #[doc(hidden)]
    __TOKEN_SENTINEL,
    SOURCE_FILE,
    NAME,
    LITERAL,
    EXPORT,
    TYPE_DECLARATION,
    FUNCTION_DECLARATION,
    NAMED_TYPE,
    BOXED_TYPE,
    REFERENCE_TYPE,
    INFERRED_TYPE,
    SLICE_TYPE,
    ARRAY_TYPE,
    STRUCT_TYPE,
    TRAIT_TYPE,
    TRAIT_ITEM,
    FUNCTION_TYPE,
    FUNCTION_PARAMETER_LIST,
    FUNCTION_PARAMETER,
    ENUM_TYPE,
    ENUM_VARIANT,
    ENUM_VARIANT_LIST,
    ENUM_VARIANT_EXPRESSION,
    UNION_TYPE,
    UNION_TYPE_BODY,
    UNION_TYPE_VARIANT_LIST,
    UNION_TYPE_VARIANT,
    STRUCT_FIELD,
    DELEGATED_FIELD,
    STRUCT_FIELD_LIST,
    TYPE_LIST,
    PARENTHESIZED_TYPE_LIST,
    GENERIC_PARAMETER_LIST,
    TYPE_PARAMETER,
    GENERIC_ARGUMENT_LIST,
    TYPE_ARGUMENT,
    CONSTRAINT,
    CONSTRAINT_LIST,
    TYPE_BOUND_LIST,
    TYPE_BOUND,
    BLOCK,
    BINARY_EXPRESSION,
    INTERPOLATED_STRING,
    INTERPOLATED_STRING_PARTS,
    INTERPOLATED_STRING_SLOT,
    #[doc(hidden)]
    __LAST,
}

use self::SyntaxKind::*;

impl SyntaxKind {
    pub fn is_punctuation(self) -> bool {
        matches!(
            self,
            LEFT_PAREN
                | RIGHT_PAREN
                | LEFT_CURLY
                | RIGHT_CURLY
                | LEFT_BRACKET
                | RIGHT_BRACKET
                | COMMA
                | DOT
                | COLON
                | SEMICOLON
                | EQUAL
                | PLUS
                | MINUS
                | STAR
                | SLASH
                | AMPERSAND
                | PIPE
                | CARET
                | TILDE
                | PERCENT
                | AT
                | HASH
                | BANG
                | QUESTION
                | DOLLAR
                | UNDERSCORE
                | DOUBLE_STAR
                | DOUBLE_DOT
                | DOUBLE_DOT_EQUAL
                | DOUBLE_EQUAL
                | DOUBLE_AMPERSAND
                | DOUBLE_PIPE
                | FAT_ARROW
                | NOT_EQUAL
                | LESS_THAN
                | GREATER_THAN
                | LESS_THAN_EQUAL
                | GREATER_THAN_EQUAL
                | PLUS_EQUAL
                | MINUS_EQUAL
                | PIPE_EQUAL
                | AMPERSAND_EQUAL
                | CARET_EQUAL
                | SLASH_EQUAL
                | STAR_EQUAL
                | PERCENT_EQUAL
                | SHIFT_LEFT
                | SHIFT_RIGHT
                | SHIFT_LEFT_EQUAL
                | SHIFT_RIGHT_EQUAL
        )
    }

    pub fn is_literal(self) -> bool {
        matches!(
            self,
            INT_LITERAL
                | FLOAT_LITERAL
                | CHAR_LITERAL
                | BYTE_LITERAL
                | STRING_LITERAL
                | STRING_LITERAL_FRAGMENT
        )
    }

    pub fn is_keyword(self) -> bool {
        matches!(
            self,
            TYPE_KW
                | STRUCT_KW
                | ENUM_KW
                | UNION_KW
                | TRAIT_KW
                | FN_KW
                | TEST_KW
                | VAL_KW
                | VAR_KW
                | CONST_KW
                | USING_KW
                | EXTEND_KW
                | IMPORT_KW
                | EXPORT_KW
                | TRUE_KW
                | FALSE_KW
                | WHERE_KW
                | BOX_KW
                | REF_KW
                | IF_KW
                | ELSE_KW
                | WHILE_KW
                | LOOP_KW
                | FOR_KW
                | DELEGATE_KW
        )
    }

    pub fn from_keyword(ident: &str) -> Option<SyntaxKind> {
        let kw = match ident {
            "type" => TYPE_KW,
            "struct" => STRUCT_KW,
            "enum" => ENUM_KW,
            "union" => UNION_KW,
            "trait" => TRAIT_KW,
            "fn" => FN_KW,
            "test" => TEST_KW,
            "val" => VAL_KW,
            "var" => VAR_KW,
            "const" => CONST_KW,
            "using" => USING_KW,
            "extend" => EXTEND_KW,
            "import" => IMPORT_KW,
            "export" => EXPORT_KW,
            "true" => TRUE_KW,
            "false" => FALSE_KW,
            "where" => WHERE_KW,
            "box" => BOX_KW,
            "ref" => REF_KW,
            "if" => IF_KW,
            "else" => ELSE_KW,
            "while" => WHILE_KW,
            "loop" => LOOP_KW,
            "for" => FOR_KW,
            "delegate" => DELEGATE_KW,
            _ => return None,
        };

        Some(kw)
    }

    pub fn from_char(c: char) -> Option<SyntaxKind> {
        let tok = match c {
            '(' => LEFT_PAREN,
            ')' => RIGHT_PAREN,
            '{' => LEFT_CURLY,
            '}' => RIGHT_CURLY,
            '[' => LEFT_BRACKET,
            ']' => RIGHT_BRACKET,
            ',' => COMMA,
            '.' => DOT,
            ':' => COLON,
            ';' => SEMICOLON,
            '=' => EQUAL,
            '+' => PLUS,
            '-' => MINUS,
            '*' => STAR,
            '/' => SLASH,
            '&' => AMPERSAND,
            '|' => PIPE,
            '^' => CARET,
            '~' => TILDE,
            '%' => PERCENT,
            '@' => AT,
            '#' => HASH,
            '!' => BANG,
            '?' => QUESTION,
            '$' => DOLLAR,
            '_' => UNDERSCORE,
            '<' => LESS_THAN,
            '>' => GREATER_THAN,
            _ => return None,
        };

        Some(tok)
    }
}

impl std::fmt::Display for SyntaxKind {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let name = match self {
            LEFT_PAREN => "(",
            RIGHT_PAREN => ")",
            LEFT_CURLY => "{",
            RIGHT_CURLY => "}",
            LEFT_BRACKET => "[",
            RIGHT_BRACKET => "]",
            COMMA => ",",
            DOT => ".",
            COLON => ":",
            SEMICOLON => ";",
            EQUAL => "=",
            PLUS => "+",
            MINUS => "-",
            STAR => "*",
            SLASH => "/",
            AMPERSAND => "&",
            PIPE => "|",
            CARET => "^",
            TILDE => "~",
            PERCENT => "%",
            AT => "@",
            HASH => "#",
            BANG => "!",
            QUESTION => "?",
            DOLLAR => "$",
            UNDERSCORE => "_",
            DOUBLE_STAR => "**",
            DOUBLE_DOT => "..",
            DOUBLE_DOT_EQUAL => "..=",
            DOUBLE_EQUAL => "==",
            DOUBLE_AMPERSAND => "&&",
            DOUBLE_PIPE => "||",
            FAT_ARROW => "=>",
            NOT_EQUAL => "!=",
            LESS_THAN => "<",
            GREATER_THAN => ">",
            LESS_THAN_EQUAL => "<=",
            GREATER_THAN_EQUAL => ">=",
            PLUS_EQUAL => "+=",
            MINUS_EQUAL => "-=",
            PIPE_EQUAL => "|=",
            AMPERSAND_EQUAL => "&=",
            CARET_EQUAL => "^=",
            SLASH_EQUAL => "/=",
            STAR_EQUAL => "*=",
            PERCENT_EQUAL => "%=",
            SHIFT_LEFT => "<<",
            SHIFT_RIGHT => ">>",
            SHIFT_LEFT_EQUAL => "<<=",
            SHIFT_RIGHT_EQUAL => ">>=",
            TYPE_KW => "type",
            STRUCT_KW => "struct",
            ENUM_KW => "enum",
            UNION_KW => "union",
            TRAIT_KW => "trait",
            FN_KW => "fn",
            TEST_KW => "test",
            VAL_KW => "val",
            VAR_KW => "var",
            CONST_KW => "const",
            USING_KW => "using",
            EXTEND_KW => "extend",
            IMPORT_KW => "import",
            EXPORT_KW => "export",
            TRUE_KW => "true",
            FALSE_KW => "false",
            WHERE_KW => "where",
            BOX_KW => "box",
            REF_KW => "ref",
            IF_KW => "if",
            ELSE_KW => "else",
            WHILE_KW => "while",
            LOOP_KW => "loop",
            FOR_KW => "for",
            DELEGATE_KW => "delegate",
            INT_LITERAL => stringify!(INT_LITERAL),
            FLOAT_LITERAL => stringify!(FLOAT_LITERAL),
            CHAR_LITERAL => stringify!(CHAR_LITERAL),
            BYTE_LITERAL => stringify!(BYTE_LITERAL),
            STRING_LITERAL => stringify!(STRING_LITERAL),
            STRING_LITERAL_FRAGMENT => stringify!(STRING_LITERAL_FRAGMENT),
            ERROR => stringify!(ERROR),
            IDENTIFIER => stringify!(IDENTIFIER),
            WHITESPACE => stringify!(WHITESPACE),
            LINE_COMMENT => stringify!(LINE_COMMENT),
            BLOCK_COMMENT => stringify!(BLOCK_COMMENT),
            INT_LITERAL_PREFIX => stringify!(INT_LITERAL_PREFIX),
            SOURCE_FILE => stringify!(SOURCE_FILE),
            NAME => stringify!(NAME),
            LITERAL => stringify!(LITERAL),
            EXPORT => stringify!(EXPORT),
            TYPE_DECLARATION => stringify!(TYPE_DECLARATION),
            FUNCTION_DECLARATION => stringify!(FUNCTION_DECLARATION),
            NAMED_TYPE => stringify!(NAMED_TYPE),
            BOXED_TYPE => stringify!(BOXED_TYPE),
            REFERENCE_TYPE => stringify!(REFERENCE_TYPE),
            INFERRED_TYPE => stringify!(INFERRED_TYPE),
            SLICE_TYPE => stringify!(SLICE_TYPE),
            ARRAY_TYPE => stringify!(ARRAY_TYPE),
            STRUCT_TYPE => stringify!(STRUCT_TYPE),
            TRAIT_TYPE => stringify!(TRAIT_TYPE),
            TRAIT_ITEM => stringify!(TRAIT_ITEM),
            FUNCTION_TYPE => stringify!(FUNCTION_TYPE),
            FUNCTION_PARAMETER_LIST => stringify!(FUNCTION_PARAMETER_LIST),
            FUNCTION_PARAMETER => stringify!(FUNCTION_PARAMETER),
            ENUM_TYPE => stringify!(ENUM_TYPE),
            ENUM_VARIANT => stringify!(ENUM_VARIANT),
            ENUM_VARIANT_LIST => stringify!(ENUM_VARIANT_LIST),
            ENUM_VARIANT_EXPRESSION => stringify!(ENUM_VARIANT_EXPRESSION),
            UNION_TYPE => stringify!(UNION_TYPE),
            UNION_TYPE_BODY => stringify!(UNION_TYPE_BODY),
            UNION_TYPE_VARIANT_LIST => stringify!(UNION_TYPE_VARIANT_LIST),
            UNION_TYPE_VARIANT => stringify!(UNION_TYPE_VARIANT),
            STRUCT_FIELD => stringify!(STRUCT_FIELD),
            DELEGATED_FIELD => stringify!(DELEGATED_FIELD),
            STRUCT_FIELD_LIST => stringify!(STRUCT_FIELD_LIST),
            TYPE_LIST => stringify!(TYPE_LIST),
            PARENTHESIZED_TYPE_LIST => stringify!(PARENTHESIZED_TYPE_LIST),
            GENERIC_PARAMETER_LIST => stringify!(GENERIC_PARAMETER_LIST),
            TYPE_PARAMETER => stringify!(TYPE_PARAMETER),
            GENERIC_ARGUMENT_LIST => stringify!(GENERIC_ARGUMENT_LIST),
            TYPE_ARGUMENT => stringify!(TYPE_ARGUMENT),
            CONSTRAINT => stringify!(CONSTRAINT),
            CONSTRAINT_LIST => stringify!(CONSTRAINT_LIST),
            TYPE_BOUND_LIST => stringify!(TYPE_BOUND_LIST),
            TYPE_BOUND => stringify!(TYPE_BOUND),
            BLOCK => stringify!(BLOCK),
            BINARY_EXPRESSION => stringify!(BINARY_EXPRESSION),
            INTERPOLATED_STRING => stringify!(INTERPOLATED_STRING),
            INTERPOLATED_STRING_PARTS => stringify!(INTERPOLATED_STRING_PARTS),
            INTERPOLATED_STRING_SLOT => stringify!(INTERPOLATED_STRING_SLOT),
            _ => unreachable!(),
        };

        write!(f, "{}", name)
    }
}

#[macro_export]
macro_rules! T { ["("] => { $ crate :: syntax :: SyntaxKind :: LEFT_PAREN } ; [")"] => { $ crate :: syntax :: SyntaxKind :: RIGHT_PAREN } ; ["{"] => { $ crate :: syntax :: SyntaxKind :: LEFT_CURLY } ; ["}"] => { $ crate :: syntax :: SyntaxKind :: RIGHT_CURLY } ; ["["] => { $ crate :: syntax :: SyntaxKind :: LEFT_BRACKET } ; ["]"] => { $ crate :: syntax :: SyntaxKind :: RIGHT_BRACKET } ; [","] => { $ crate :: syntax :: SyntaxKind :: COMMA } ; ["."] => { $ crate :: syntax :: SyntaxKind :: DOT } ; [":"] => { $ crate :: syntax :: SyntaxKind :: COLON } ; [";"] => { $ crate :: syntax :: SyntaxKind :: SEMICOLON } ; ["="] => { $ crate :: syntax :: SyntaxKind :: EQUAL } ; ["+"] => { $ crate :: syntax :: SyntaxKind :: PLUS } ; ["-"] => { $ crate :: syntax :: SyntaxKind :: MINUS } ; ["*"] => { $ crate :: syntax :: SyntaxKind :: STAR } ; ["/"] => { $ crate :: syntax :: SyntaxKind :: SLASH } ; ["&"] => { $ crate :: syntax :: SyntaxKind :: AMPERSAND } ; ["|"] => { $ crate :: syntax :: SyntaxKind :: PIPE } ; ["^"] => { $ crate :: syntax :: SyntaxKind :: CARET } ; ["~"] => { $ crate :: syntax :: SyntaxKind :: TILDE } ; ["%"] => { $ crate :: syntax :: SyntaxKind :: PERCENT } ; ["@"] => { $ crate :: syntax :: SyntaxKind :: AT } ; ["#"] => { $ crate :: syntax :: SyntaxKind :: HASH } ; ["!"] => { $ crate :: syntax :: SyntaxKind :: BANG } ; ["?"] => { $ crate :: syntax :: SyntaxKind :: QUESTION } ; ["$"] => { $ crate :: syntax :: SyntaxKind :: DOLLAR } ; ["_"] => { $ crate :: syntax :: SyntaxKind :: UNDERSCORE } ; ["**"] => { $ crate :: syntax :: SyntaxKind :: DOUBLE_STAR } ; [".."] => { $ crate :: syntax :: SyntaxKind :: DOUBLE_DOT } ; ["..="] => { $ crate :: syntax :: SyntaxKind :: DOUBLE_DOT_EQUAL } ; ["=="] => { $ crate :: syntax :: SyntaxKind :: DOUBLE_EQUAL } ; ["&&"] => { $ crate :: syntax :: SyntaxKind :: DOUBLE_AMPERSAND } ; ["||"] => { $ crate :: syntax :: SyntaxKind :: DOUBLE_PIPE } ; ["=>"] => { $ crate :: syntax :: SyntaxKind :: FAT_ARROW } ; ["!="] => { $ crate :: syntax :: SyntaxKind :: NOT_EQUAL } ; ["<"] => { $ crate :: syntax :: SyntaxKind :: LESS_THAN } ; [">"] => { $ crate :: syntax :: SyntaxKind :: GREATER_THAN } ; ["<="] => { $ crate :: syntax :: SyntaxKind :: LESS_THAN_EQUAL } ; [">="] => { $ crate :: syntax :: SyntaxKind :: GREATER_THAN_EQUAL } ; ["+="] => { $ crate :: syntax :: SyntaxKind :: PLUS_EQUAL } ; ["-="] => { $ crate :: syntax :: SyntaxKind :: MINUS_EQUAL } ; ["|="] => { $ crate :: syntax :: SyntaxKind :: PIPE_EQUAL } ; ["&="] => { $ crate :: syntax :: SyntaxKind :: AMPERSAND_EQUAL } ; ["^="] => { $ crate :: syntax :: SyntaxKind :: CARET_EQUAL } ; ["/="] => { $ crate :: syntax :: SyntaxKind :: SLASH_EQUAL } ; ["*="] => { $ crate :: syntax :: SyntaxKind :: STAR_EQUAL } ; ["%="] => { $ crate :: syntax :: SyntaxKind :: PERCENT_EQUAL } ; ["<<"] => { $ crate :: syntax :: SyntaxKind :: SHIFT_LEFT } ; [">>"] => { $ crate :: syntax :: SyntaxKind :: SHIFT_RIGHT } ; ["<<="] => { $ crate :: syntax :: SyntaxKind :: SHIFT_LEFT_EQUAL } ; [">>="] => { $ crate :: syntax :: SyntaxKind :: SHIFT_RIGHT_EQUAL } ; ["type"] => { $ crate :: syntax :: SyntaxKind :: TYPE_KW } ; ["struct"] => { $ crate :: syntax :: SyntaxKind :: STRUCT_KW } ; ["enum"] => { $ crate :: syntax :: SyntaxKind :: ENUM_KW } ; ["union"] => { $ crate :: syntax :: SyntaxKind :: UNION_KW } ; ["trait"] => { $ crate :: syntax :: SyntaxKind :: TRAIT_KW } ; ["fn"] => { $ crate :: syntax :: SyntaxKind :: FN_KW } ; ["test"] => { $ crate :: syntax :: SyntaxKind :: TEST_KW } ; ["val"] => { $ crate :: syntax :: SyntaxKind :: VAL_KW } ; ["var"] => { $ crate :: syntax :: SyntaxKind :: VAR_KW } ; ["const"] => { $ crate :: syntax :: SyntaxKind :: CONST_KW } ; ["using"] => { $ crate :: syntax :: SyntaxKind :: USING_KW } ; ["extend"] => { $ crate :: syntax :: SyntaxKind :: EXTEND_KW } ; ["import"] => { $ crate :: syntax :: SyntaxKind :: IMPORT_KW } ; ["export"] => { $ crate :: syntax :: SyntaxKind :: EXPORT_KW } ; ["true"] => { $ crate :: syntax :: SyntaxKind :: TRUE_KW } ; ["false"] => { $ crate :: syntax :: SyntaxKind :: FALSE_KW } ; ["where"] => { $ crate :: syntax :: SyntaxKind :: WHERE_KW } ; ["box"] => { $ crate :: syntax :: SyntaxKind :: BOX_KW } ; ["ref"] => { $ crate :: syntax :: SyntaxKind :: REF_KW } ; ["if"] => { $ crate :: syntax :: SyntaxKind :: IF_KW } ; ["else"] => { $ crate :: syntax :: SyntaxKind :: ELSE_KW } ; ["while"] => { $ crate :: syntax :: SyntaxKind :: WHILE_KW } ; ["loop"] => { $ crate :: syntax :: SyntaxKind :: LOOP_KW } ; ["for"] => { $ crate :: syntax :: SyntaxKind :: FOR_KW } ; ["delegate"] => { $ crate :: syntax :: SyntaxKind :: DELEGATE_KW } ; ["identifier"] => { $ crate :: syntax :: SyntaxKind :: IDENTIFIER } ; }
