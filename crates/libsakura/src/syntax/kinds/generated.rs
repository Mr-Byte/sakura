//! Code generated by `cargo xtask codegen`; DO NOT EDIT.

#![allow(
    dead_code,
    bad_style,
    missing_docs,
    unreachable_pub,
    clippy::manual_non_exhaustive,
    clippy::upper_case_acronyms
)]
#[non_exhaustive]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(u16)]
pub enum SyntaxKind {
    #[doc(hidden)]
    TOMBSTONE,
    #[doc(hidden)]
    EOF,
    LEFT_PAREN,
    RIGHT_PAREN,
    LEFT_CURLY,
    RIGHT_CURLY,
    LEFT_BRACKET,
    RIGHT_BRACKET,
    COMMA,
    DOT,
    COLON,
    EQUAL,
    PLUS,
    MINUS,
    STAR,
    SLASH,
    AMPERSAND,
    PIPE,
    CARET,
    TILDE,
    PERCENT,
    AT,
    HASH,
    BANG,
    QUESTION,
    DOLLAR,
    DOUBLE_STAR,
    DOUBLE_DOT,
    DOUBLE_DOT_EQUAL,
    DOUBLE_EQUAL,
    DOUBLE_AMPERSAND,
    DOUBLE_PIPE,
    FAT_ARROW,
    NOT_EQUAL,
    LESS_THAN,
    GREATER_THAN,
    LESS_THAN_EQUAL,
    GREATER_THAN_EQUAL,
    PLUS_EQUAL,
    MINUS_EQUAL,
    PIPE_EQUAL,
    AMPERSAND_EQUAL,
    CARET_EQUAL,
    SLASH_EQUAL,
    STAR_EQUAL,
    PERCENT_EQUAL,
    SHIFT_LEFT,
    SHIFT_RIGHT,
    SHIFT_LEFT_EQUAL,
    SHIFT_RIGHT_EQUAL,
    STRING_LITERAL,
    INT_LITERAL,
    FLOAT_LITERAL,
    CHAR_LITERAL,
    BYTE_LITERAL,
    STRING_LITERAL_FRAGMENT,
    IDENTIFIER,
    WHITESPACE,
    ERROR,
    LINE_COMMENT,
    BLOCK_COMMENT,
    #[doc(hidden)]
    __LAST,
}
use self::SyntaxKind::*;
impl SyntaxKind {
    pub fn is_punctuation(self) -> bool {
        matches!(
            self,
            LEFT_PAREN
                | RIGHT_PAREN
                | LEFT_CURLY
                | RIGHT_CURLY
                | LEFT_BRACKET
                | RIGHT_BRACKET
                | COMMA
                | DOT
                | COLON
                | EQUAL
                | PLUS
                | MINUS
                | STAR
                | SLASH
                | AMPERSAND
                | PIPE
                | CARET
                | TILDE
                | PERCENT
                | AT
                | HASH
                | BANG
                | QUESTION
                | DOLLAR
                | DOUBLE_STAR
                | DOUBLE_DOT
                | DOUBLE_DOT_EQUAL
                | DOUBLE_EQUAL
                | DOUBLE_AMPERSAND
                | DOUBLE_PIPE
                | FAT_ARROW
                | NOT_EQUAL
                | LESS_THAN
                | GREATER_THAN
                | LESS_THAN_EQUAL
                | GREATER_THAN_EQUAL
                | PLUS_EQUAL
                | MINUS_EQUAL
                | PIPE_EQUAL
                | AMPERSAND_EQUAL
                | CARET_EQUAL
                | SLASH_EQUAL
                | STAR_EQUAL
                | PERCENT_EQUAL
                | SHIFT_LEFT
                | SHIFT_RIGHT
                | SHIFT_LEFT_EQUAL
                | SHIFT_RIGHT_EQUAL
        )
    }
    pub fn is_literal(self) -> bool {
        matches!(
            self,
            STRING_LITERAL
                | INT_LITERAL
                | FLOAT_LITERAL
                | CHAR_LITERAL
                | BYTE_LITERAL
                | STRING_LITERAL_FRAGMENT
        )
    }
    pub fn from_char(c: char) -> Option<SyntaxKind> {
        let tok = match c {
            '(' => LEFT_PAREN,
            ')' => RIGHT_PAREN,
            '{' => LEFT_CURLY,
            '}' => RIGHT_CURLY,
            '[' => LEFT_BRACKET,
            ']' => RIGHT_BRACKET,
            ',' => COMMA,
            '.' => DOT,
            ':' => COLON,
            '=' => EQUAL,
            '+' => PLUS,
            '-' => MINUS,
            '*' => STAR,
            '/' => SLASH,
            '&' => AMPERSAND,
            '|' => PIPE,
            '^' => CARET,
            '~' => TILDE,
            '%' => PERCENT,
            '@' => AT,
            '#' => HASH,
            '!' => BANG,
            '?' => QUESTION,
            '$' => DOLLAR,
            '<' => LESS_THAN,
            '>' => GREATER_THAN,
            _ => return None,
        };
        Some(tok)
    }
}
#[macro_export]
macro_rules ! T { ['('] => { $ crate :: SyntaxKind :: LEFT_PAREN } ; [')'] => { $ crate :: SyntaxKind :: RIGHT_PAREN } ; ['{'] => { $ crate :: SyntaxKind :: LEFT_CURLY } ; ['}'] => { $ crate :: SyntaxKind :: RIGHT_CURLY } ; ['['] => { $ crate :: SyntaxKind :: LEFT_BRACKET } ; [']'] => { $ crate :: SyntaxKind :: RIGHT_BRACKET } ; [,] => { $ crate :: SyntaxKind :: COMMA } ; [.] => { $ crate :: SyntaxKind :: DOT } ; [:] => { $ crate :: SyntaxKind :: COLON } ; [=] => { $ crate :: SyntaxKind :: EQUAL } ; [+] => { $ crate :: SyntaxKind :: PLUS } ; [-] => { $ crate :: SyntaxKind :: MINUS } ; [*] => { $ crate :: SyntaxKind :: STAR } ; [/] => { $ crate :: SyntaxKind :: SLASH } ; [&] => { $ crate :: SyntaxKind :: AMPERSAND } ; [|] => { $ crate :: SyntaxKind :: PIPE } ; [^] => { $ crate :: SyntaxKind :: CARET } ; [~] => { $ crate :: SyntaxKind :: TILDE } ; [%] => { $ crate :: SyntaxKind :: PERCENT } ; [@] => { $ crate :: SyntaxKind :: AT } ; [#] => { $ crate :: SyntaxKind :: HASH } ; [!] => { $ crate :: SyntaxKind :: BANG } ; [?] => { $ crate :: SyntaxKind :: QUESTION } ; [$] => { $ crate :: SyntaxKind :: DOLLAR } ; [**] => { $ crate :: SyntaxKind :: DOUBLE_STAR } ; [..] => { $ crate :: SyntaxKind :: DOUBLE_DOT } ; [..=] => { $ crate :: SyntaxKind :: DOUBLE_DOT_EQUAL } ; [==] => { $ crate :: SyntaxKind :: DOUBLE_EQUAL } ; [&&] => { $ crate :: SyntaxKind :: DOUBLE_AMPERSAND } ; [||] => { $ crate :: SyntaxKind :: DOUBLE_PIPE } ; [=>] => { $ crate :: SyntaxKind :: FAT_ARROW } ; [!=] => { $ crate :: SyntaxKind :: NOT_EQUAL } ; [<] => { $ crate :: SyntaxKind :: LESS_THAN } ; [>] => { $ crate :: SyntaxKind :: GREATER_THAN } ; [<=] => { $ crate :: SyntaxKind :: LESS_THAN_EQUAL } ; [>=] => { $ crate :: SyntaxKind :: GREATER_THAN_EQUAL } ; [+=] => { $ crate :: SyntaxKind :: PLUS_EQUAL } ; [-=] => { $ crate :: SyntaxKind :: MINUS_EQUAL } ; [|=] => { $ crate :: SyntaxKind :: PIPE_EQUAL } ; [&=] => { $ crate :: SyntaxKind :: AMPERSAND_EQUAL } ; [^=] => { $ crate :: SyntaxKind :: CARET_EQUAL } ; [/=] => { $ crate :: SyntaxKind :: SLASH_EQUAL } ; [*=] => { $ crate :: SyntaxKind :: STAR_EQUAL } ; [%=] => { $ crate :: SyntaxKind :: PERCENT_EQUAL } ; [<<] => { $ crate :: SyntaxKind :: SHIFT_LEFT } ; [>>] => { $ crate :: SyntaxKind :: SHIFT_RIGHT } ; [<<=] => { $ crate :: SyntaxKind :: SHIFT_LEFT_EQUAL } ; [>>=] => { $ crate :: SyntaxKind :: SHIFT_RIGHT_EQUAL } ; [IDENTIFIER] => { $ crate :: SyntaxKind :: IDENTIFIER } ; }
