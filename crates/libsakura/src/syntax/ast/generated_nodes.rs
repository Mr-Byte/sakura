//! Code generated by `cargo xtask codegen`; DO NOT EDIT.

use super::support;
use crate::syntax::ast::{AstChildren, AstNode};
use crate::syntax::{
    SyntaxKind::{self, *},
    SyntaxNode, SyntaxToken,
};
use crate::T;

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Export {
    pub(crate) syntax: SyntaxNode,
}

impl Export {
    pub fn export_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!["export"])
    }
}

impl AstNode for Export {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == EXPORT
    }

    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }

    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct SourceFile {
    pub(crate) syntax: SyntaxNode,
}

impl SourceFile {
    pub fn items(&self) -> AstChildren<Item> {
        support::children(&self.syntax)
    }
}

impl AstNode for SourceFile {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SOURCE_FILE
    }

    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }

    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TypeDeclaration {
    pub(crate) syntax: SyntaxNode,
}

impl TypeDeclaration {
    pub fn export(&self) -> Option<Export> {
        support::child(&self.syntax)
    }

    pub fn type_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!["type"])
    }

    pub fn name(&self) -> Option<Name> {
        support::child(&self.syntax)
    }

    pub fn generic_parameters(&self) -> Option<GenericParameterList> {
        support::child(&self.syntax)
    }

    pub fn constraints(&self) -> Option<ConstraintList> {
        support::child(&self.syntax)
    }

    pub fn equal_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!["="])
    }

    pub fn body(&self) -> Option<Type> {
        support::child(&self.syntax)
    }
}

impl AstNode for TypeDeclaration {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == TYPE_DECLARATION
    }

    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }

    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct FunctionDeclaration {
    pub(crate) syntax: SyntaxNode,
}

impl FunctionDeclaration {
    pub fn export(&self) -> Option<Export> {
        support::child(&self.syntax)
    }

    pub fn fn_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!["fn"])
    }

    pub fn name(&self) -> Option<Name> {
        support::child(&self.syntax)
    }

    pub fn generic_parameters(&self) -> Option<GenericParameterList> {
        support::child(&self.syntax)
    }

    pub fn constraints(&self) -> Option<ConstraintList> {
        support::child(&self.syntax)
    }

    pub fn parameters(&self) -> Option<FunctionParameterList> {
        support::child(&self.syntax)
    }

    pub fn colon_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![":"])
    }

    pub fn ty(&self) -> Option<Type> {
        support::child(&self.syntax)
    }

    pub fn body(&self) -> Option<Block> {
        support::child(&self.syntax)
    }
}

impl AstNode for FunctionDeclaration {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == FUNCTION_DECLARATION
    }

    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }

    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Name {
    pub(crate) syntax: SyntaxNode,
}

impl Name {
    pub fn identifier_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!["identifier"])
    }
}

impl AstNode for Name {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == NAME
    }

    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }

    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct GenericParameterList {
    pub(crate) syntax: SyntaxNode,
}

impl GenericParameterList {
    pub fn left_bracket_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!["["])
    }

    pub fn params(&self) -> AstChildren<Name> {
        support::children(&self.syntax)
    }

    pub fn right_bracket_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!["]"])
    }
}

impl AstNode for GenericParameterList {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == GENERIC_PARAMETER_LIST
    }

    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }

    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ConstraintList {
    pub(crate) syntax: SyntaxNode,
}

impl ConstraintList {
    pub fn constraints(&self) -> AstChildren<Constraint> {
        support::children(&self.syntax)
    }
}

impl AstNode for ConstraintList {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == CONSTRAINT_LIST
    }

    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }

    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct FunctionParameterList {
    pub(crate) syntax: SyntaxNode,
}

impl FunctionParameterList {
    pub fn left_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!["("])
    }

    pub fn parameters(&self) -> AstChildren<FunctionParameter> {
        support::children(&self.syntax)
    }

    pub fn right_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![")"])
    }
}

impl AstNode for FunctionParameterList {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == FUNCTION_PARAMETER_LIST
    }

    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }

    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Block {
    pub(crate) syntax: SyntaxNode,
}

impl Block {
    pub fn left_curly_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!["{"])
    }

    pub fn expressions(&self) -> AstChildren<Expression> {
        support::children(&self.syntax)
    }

    pub fn right_curly_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!["}"])
    }
}

impl AstNode for Block {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == BLOCK
    }

    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }

    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct FunctionParameter {
    pub(crate) syntax: SyntaxNode,
}

impl FunctionParameter {
    pub fn name(&self) -> Option<Name> {
        support::child(&self.syntax)
    }

    pub fn colon_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![":"])
    }

    pub fn ty(&self) -> Option<Type> {
        support::child(&self.syntax)
    }
}

impl AstNode for FunctionParameter {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == FUNCTION_PARAMETER
    }

    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }

    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct NamedType {
    pub(crate) syntax: SyntaxNode,
}

impl NamedType {
    pub fn name(&self) -> Option<Name> {
        support::child(&self.syntax)
    }

    pub fn generic_argument_list(&self) -> Option<GenericArgumentList> {
        support::child(&self.syntax)
    }
}

impl AstNode for NamedType {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == NAMED_TYPE
    }

    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }

    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct BoxedType {
    pub(crate) syntax: SyntaxNode,
}

impl BoxedType {
    pub fn box_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!["box"])
    }

    pub fn ty(&self) -> Option<Type> {
        support::child(&self.syntax)
    }
}

impl AstNode for BoxedType {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == BOXED_TYPE
    }

    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }

    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ReferenceType {
    pub(crate) syntax: SyntaxNode,
}

impl ReferenceType {
    pub fn ref_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!["ref"])
    }

    pub fn ty(&self) -> Option<Type> {
        support::child(&self.syntax)
    }
}

impl AstNode for ReferenceType {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == REFERENCE_TYPE
    }

    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }

    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct InferredType {
    pub(crate) syntax: SyntaxNode,
}

impl InferredType {
    pub fn _token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!["_"])
    }
}

impl AstNode for InferredType {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == INFERRED_TYPE
    }

    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }

    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct SliceType {
    pub(crate) syntax: SyntaxNode,
}

impl SliceType {
    pub fn left_bracket_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!["["])
    }

    pub fn ty(&self) -> Option<Type> {
        support::child(&self.syntax)
    }

    pub fn right_bracket_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!["]"])
    }
}

impl AstNode for SliceType {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SLICE_TYPE
    }

    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }

    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ArrayType {
    pub(crate) syntax: SyntaxNode,
}

impl ArrayType {
    pub fn left_bracket_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!["["])
    }

    pub fn ty(&self) -> Option<Type> {
        support::child(&self.syntax)
    }

    pub fn semicolon_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![";"])
    }

    pub fn expression(&self) -> Option<Expression> {
        support::child(&self.syntax)
    }

    pub fn right_bracket_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!["]"])
    }
}

impl AstNode for ArrayType {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == ARRAY_TYPE
    }

    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }

    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct StructType {
    pub(crate) syntax: SyntaxNode,
}

impl StructType {
    pub fn struct_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!["struct"])
    }

    pub fn body(&self) -> Option<StructFieldList> {
        support::child(&self.syntax)
    }
}

impl AstNode for StructType {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == STRUCT_TYPE
    }

    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }

    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct EnumType {
    pub(crate) syntax: SyntaxNode,
}

impl EnumType {
    pub fn enum_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!["enum"])
    }

    pub fn enum_variant_list(&self) -> Option<EnumVariantList> {
        support::child(&self.syntax)
    }
}

impl AstNode for EnumType {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == ENUM_TYPE
    }

    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }

    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct UnionType {
    pub(crate) syntax: SyntaxNode,
}

impl UnionType {
    pub fn union_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!["union"])
    }

    pub fn union_type_body(&self) -> Option<UnionTypeBody> {
        support::child(&self.syntax)
    }
}

impl AstNode for UnionType {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == UNION_TYPE
    }

    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }

    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TraitType {
    pub(crate) syntax: SyntaxNode,
}

impl TraitType {
    pub fn trait_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!["trait"])
    }

    pub fn left_curly_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!["{"])
    }

    pub fn items(&self) -> AstChildren<TraitItem> {
        support::children(&self.syntax)
    }

    pub fn right_curly_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!["}"])
    }
}

impl AstNode for TraitType {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == TRAIT_TYPE
    }

    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }

    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct FunctionType {
    pub(crate) syntax: SyntaxNode,
}

impl FunctionType {
    pub fn fn_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!["fn"])
    }

    pub fn generic_parameters(&self) -> Option<GenericParameterList> {
        support::child(&self.syntax)
    }

    pub fn constraints(&self) -> Option<ConstraintList> {
        support::child(&self.syntax)
    }

    pub fn parameters(&self) -> Option<ParenthesizedTypeList> {
        support::child(&self.syntax)
    }

    pub fn colon_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![":"])
    }

    pub fn ty(&self) -> Option<Type> {
        support::child(&self.syntax)
    }
}

impl AstNode for FunctionType {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == FUNCTION_TYPE
    }

    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }

    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct GenericArgumentList {
    pub(crate) syntax: SyntaxNode,
}

impl GenericArgumentList {
    pub fn left_bracket_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!["["])
    }

    pub fn arguments(&self) -> AstChildren<TypeArgument> {
        support::children(&self.syntax)
    }

    pub fn right_bracket_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!["]"])
    }
}

impl AstNode for GenericArgumentList {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == GENERIC_ARGUMENT_LIST
    }

    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }

    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct StructFieldList {
    pub(crate) syntax: SyntaxNode,
}

impl StructFieldList {
    pub fn left_curly_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!["{"])
    }

    pub fn fields(&self) -> AstChildren<StructField> {
        support::children(&self.syntax)
    }

    pub fn right_curly_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!["}"])
    }
}

impl AstNode for StructFieldList {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == STRUCT_FIELD_LIST
    }

    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }

    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct StructField {
    pub(crate) syntax: SyntaxNode,
}

impl StructField {
    pub fn name(&self) -> Option<Name> {
        support::child(&self.syntax)
    }

    pub fn colon_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![":"])
    }

    pub fn ty(&self) -> Option<Type> {
        support::child(&self.syntax)
    }

    pub fn delegated_field(&self) -> Option<DelegatedField> {
        support::child(&self.syntax)
    }
}

impl AstNode for StructField {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == STRUCT_FIELD
    }

    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }

    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct DelegatedField {
    pub(crate) syntax: SyntaxNode,
}

impl DelegatedField {
    pub fn delegate_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!["delegate"])
    }

    pub fn ty(&self) -> Option<Type> {
        support::child(&self.syntax)
    }
}

impl AstNode for DelegatedField {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == DELEGATED_FIELD
    }

    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }

    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct EnumVariantList {
    pub(crate) syntax: SyntaxNode,
}

impl EnumVariantList {
    pub fn left_curly_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!["{"])
    }

    pub fn variants(&self) -> AstChildren<EnumVariant> {
        support::children(&self.syntax)
    }

    pub fn right_curly_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!["}"])
    }
}

impl AstNode for EnumVariantList {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == ENUM_VARIANT_LIST
    }

    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }

    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct EnumVariant {
    pub(crate) syntax: SyntaxNode,
}

impl EnumVariant {
    pub fn name(&self) -> Option<Name> {
        support::child(&self.syntax)
    }

    pub fn expression(&self) -> Option<EnumVariantExpression> {
        support::child(&self.syntax)
    }
}

impl AstNode for EnumVariant {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == ENUM_VARIANT
    }

    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }

    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct EnumVariantExpression {
    pub(crate) syntax: SyntaxNode,
}

impl EnumVariantExpression {
    pub fn equal_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!["="])
    }
}

impl AstNode for EnumVariantExpression {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == ENUM_VARIANT_EXPRESSION
    }

    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }

    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct UnionTypeBody {
    pub(crate) syntax: SyntaxNode,
}

impl UnionTypeBody {
    pub fn union_type_variant_list(&self) -> Option<UnionTypeVariantList> {
        support::child(&self.syntax)
    }
}

impl AstNode for UnionTypeBody {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == UNION_TYPE_BODY
    }

    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }

    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct UnionTypeVariantList {
    pub(crate) syntax: SyntaxNode,
}

impl UnionTypeVariantList {
    pub fn left_curly_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!["{"])
    }

    pub fn variants(&self) -> AstChildren<UnionTypeVariant> {
        support::children(&self.syntax)
    }

    pub fn right_curly_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!["}"])
    }
}

impl AstNode for UnionTypeVariantList {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == UNION_TYPE_VARIANT_LIST
    }

    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }

    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct UnionTypeVariant {
    pub(crate) syntax: SyntaxNode,
}

impl UnionTypeVariant {
    pub fn name(&self) -> Option<Name> {
        support::child(&self.syntax)
    }

    pub fn parenthesized_type_list(&self) -> Option<ParenthesizedTypeList> {
        support::child(&self.syntax)
    }
}

impl AstNode for UnionTypeVariant {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == UNION_TYPE_VARIANT
    }

    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }

    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ParenthesizedTypeList {
    pub(crate) syntax: SyntaxNode,
}

impl ParenthesizedTypeList {
    pub fn left_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!["("])
    }

    pub fn type_list(&self) -> Option<TypeList> {
        support::child(&self.syntax)
    }

    pub fn right_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![")"])
    }
}

impl AstNode for ParenthesizedTypeList {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == PARENTHESIZED_TYPE_LIST
    }

    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }

    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TypeList {
    pub(crate) syntax: SyntaxNode,
}

impl TypeList {
    pub fn types(&self) -> AstChildren<Type> {
        support::children(&self.syntax)
    }
}

impl AstNode for TypeList {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == TYPE_LIST
    }

    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }

    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TraitItem {
    pub(crate) syntax: SyntaxNode,
}

impl TraitItem {
    pub fn function_type(&self) -> Option<FunctionType> {
        support::child(&self.syntax)
    }
}

impl AstNode for TraitItem {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == TRAIT_ITEM
    }

    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }

    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TypeParameter {
    pub(crate) syntax: SyntaxNode,
}

impl TypeParameter {
    pub fn name(&self) -> Option<Name> {
        support::child(&self.syntax)
    }

    pub fn equal_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!["="])
    }

    pub fn default_type(&self) -> Option<NamedType> {
        support::child(&self.syntax)
    }
}

impl AstNode for TypeParameter {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == TYPE_PARAMETER
    }

    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }

    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TypeArgument {
    pub(crate) syntax: SyntaxNode,
}

impl TypeArgument {
    pub fn named_type(&self) -> Option<NamedType> {
        support::child(&self.syntax)
    }
}

impl AstNode for TypeArgument {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == TYPE_ARGUMENT
    }

    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }

    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Constraint {
    pub(crate) syntax: SyntaxNode,
}

impl Constraint {
    pub fn where_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!["where"])
    }

    pub fn param(&self) -> Option<Name> {
        support::child(&self.syntax)
    }

    pub fn colon_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![":"])
    }

    pub fn bounds(&self) -> Option<TypeList> {
        support::child(&self.syntax)
    }
}

impl AstNode for Constraint {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == CONSTRAINT
    }

    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }

    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TypeBoundList {
    pub(crate) syntax: SyntaxNode,
}

impl TypeBoundList {
    pub fn bounds(&self) -> AstChildren<TypeBound> {
        support::children(&self.syntax)
    }
}

impl AstNode for TypeBoundList {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == TYPE_BOUND_LIST
    }

    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }

    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TypeBound {
    pub(crate) syntax: SyntaxNode,
}

impl TypeBound {
    pub fn ty(&self) -> Option<Type> {
        support::child(&self.syntax)
    }
}

impl AstNode for TypeBound {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == TYPE_BOUND
    }

    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }

    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct BinaryExpression {
    pub(crate) syntax: SyntaxNode,
}

impl BinaryExpression {}

impl AstNode for BinaryExpression {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == BINARY_EXPRESSION
    }

    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }

    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct InterpolatedString {
    pub(crate) syntax: SyntaxNode,
}

impl InterpolatedString {}

impl AstNode for InterpolatedString {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == INTERPOLATED_STRING
    }

    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }

    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Literal {
    pub(crate) syntax: SyntaxNode,
}

impl Literal {}

impl AstNode for Literal {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == LITERAL
    }

    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }

    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct InterpolatedStringParts {
    pub(crate) syntax: SyntaxNode,
}

impl InterpolatedStringParts {}

impl AstNode for InterpolatedStringParts {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == INTERPOLATED_STRING_PARTS
    }

    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }

    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct InterpolatedStringSlot {
    pub(crate) syntax: SyntaxNode,
}

impl InterpolatedStringSlot {
    pub fn dollar_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!["$"])
    }

    pub fn left_curly_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!["{"])
    }

    pub fn expression(&self) -> Option<Expression> {
        support::child(&self.syntax)
    }

    pub fn right_curly_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!["}"])
    }
}

impl AstNode for InterpolatedStringSlot {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == INTERPOLATED_STRING_SLOT
    }

    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }

    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum Item {
    TypeDeclaration(TypeDeclaration),
    FunctionDeclaration(FunctionDeclaration),
}

impl From<TypeDeclaration> for Item {
    fn from(node: TypeDeclaration) -> Item {
        Item::TypeDeclaration(node)
    }
}

impl From<FunctionDeclaration> for Item {
    fn from(node: FunctionDeclaration) -> Item {
        Item::FunctionDeclaration(node)
    }
}

impl AstNode for Item {
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(kind, TYPE_DECLARATION | FUNCTION_DECLARATION)
    }

    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            TYPE_DECLARATION => Item::TypeDeclaration(TypeDeclaration { syntax }),
            FUNCTION_DECLARATION => Item::FunctionDeclaration(FunctionDeclaration { syntax }),
            _ => return None,
        };

        Some(res)
    }

    fn syntax(&self) -> &SyntaxNode {
        match self {
            Item::TypeDeclaration(it) => it.syntax(),
            Item::FunctionDeclaration(it) => it.syntax(),
        }
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum Type {
    NamedType(NamedType),
    BoxedType(BoxedType),
    ReferenceType(ReferenceType),
    InferredType(InferredType),
    SliceType(SliceType),
    ArrayType(ArrayType),
    StructType(StructType),
    EnumType(EnumType),
    UnionType(UnionType),
    TraitType(TraitType),
    FunctionType(FunctionType),
}

impl From<NamedType> for Type {
    fn from(node: NamedType) -> Type {
        Type::NamedType(node)
    }
}

impl From<BoxedType> for Type {
    fn from(node: BoxedType) -> Type {
        Type::BoxedType(node)
    }
}

impl From<ReferenceType> for Type {
    fn from(node: ReferenceType) -> Type {
        Type::ReferenceType(node)
    }
}

impl From<InferredType> for Type {
    fn from(node: InferredType) -> Type {
        Type::InferredType(node)
    }
}

impl From<SliceType> for Type {
    fn from(node: SliceType) -> Type {
        Type::SliceType(node)
    }
}

impl From<ArrayType> for Type {
    fn from(node: ArrayType) -> Type {
        Type::ArrayType(node)
    }
}

impl From<StructType> for Type {
    fn from(node: StructType) -> Type {
        Type::StructType(node)
    }
}

impl From<EnumType> for Type {
    fn from(node: EnumType) -> Type {
        Type::EnumType(node)
    }
}

impl From<UnionType> for Type {
    fn from(node: UnionType) -> Type {
        Type::UnionType(node)
    }
}

impl From<TraitType> for Type {
    fn from(node: TraitType) -> Type {
        Type::TraitType(node)
    }
}

impl From<FunctionType> for Type {
    fn from(node: FunctionType) -> Type {
        Type::FunctionType(node)
    }
}

impl AstNode for Type {
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(
            kind,
            NAMED_TYPE
                | BOXED_TYPE
                | REFERENCE_TYPE
                | INFERRED_TYPE
                | SLICE_TYPE
                | ARRAY_TYPE
                | STRUCT_TYPE
                | ENUM_TYPE
                | UNION_TYPE
                | TRAIT_TYPE
                | FUNCTION_TYPE
        )
    }

    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            NAMED_TYPE => Type::NamedType(NamedType { syntax }),
            BOXED_TYPE => Type::BoxedType(BoxedType { syntax }),
            REFERENCE_TYPE => Type::ReferenceType(ReferenceType { syntax }),
            INFERRED_TYPE => Type::InferredType(InferredType { syntax }),
            SLICE_TYPE => Type::SliceType(SliceType { syntax }),
            ARRAY_TYPE => Type::ArrayType(ArrayType { syntax }),
            STRUCT_TYPE => Type::StructType(StructType { syntax }),
            ENUM_TYPE => Type::EnumType(EnumType { syntax }),
            UNION_TYPE => Type::UnionType(UnionType { syntax }),
            TRAIT_TYPE => Type::TraitType(TraitType { syntax }),
            FUNCTION_TYPE => Type::FunctionType(FunctionType { syntax }),
            _ => return None,
        };

        Some(res)
    }

    fn syntax(&self) -> &SyntaxNode {
        match self {
            Type::NamedType(it) => it.syntax(),
            Type::BoxedType(it) => it.syntax(),
            Type::ReferenceType(it) => it.syntax(),
            Type::InferredType(it) => it.syntax(),
            Type::SliceType(it) => it.syntax(),
            Type::ArrayType(it) => it.syntax(),
            Type::StructType(it) => it.syntax(),
            Type::EnumType(it) => it.syntax(),
            Type::UnionType(it) => it.syntax(),
            Type::TraitType(it) => it.syntax(),
            Type::FunctionType(it) => it.syntax(),
        }
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum Expression {
    BinaryExpression(BinaryExpression),
    InterpolatedString(InterpolatedString),
    Literal(Literal),
    Name(Name),
    Block(Block),
}

impl From<BinaryExpression> for Expression {
    fn from(node: BinaryExpression) -> Expression {
        Expression::BinaryExpression(node)
    }
}

impl From<InterpolatedString> for Expression {
    fn from(node: InterpolatedString) -> Expression {
        Expression::InterpolatedString(node)
    }
}

impl From<Literal> for Expression {
    fn from(node: Literal) -> Expression {
        Expression::Literal(node)
    }
}

impl From<Name> for Expression {
    fn from(node: Name) -> Expression {
        Expression::Name(node)
    }
}

impl From<Block> for Expression {
    fn from(node: Block) -> Expression {
        Expression::Block(node)
    }
}

impl AstNode for Expression {
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(kind, BINARY_EXPRESSION | INTERPOLATED_STRING | LITERAL | NAME | BLOCK)
    }

    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            BINARY_EXPRESSION => Expression::BinaryExpression(BinaryExpression { syntax }),
            INTERPOLATED_STRING => Expression::InterpolatedString(InterpolatedString { syntax }),
            LITERAL => Expression::Literal(Literal { syntax }),
            NAME => Expression::Name(Name { syntax }),
            BLOCK => Expression::Block(Block { syntax }),
            _ => return None,
        };

        Some(res)
    }

    fn syntax(&self) -> &SyntaxNode {
        match self {
            Expression::BinaryExpression(it) => it.syntax(),
            Expression::InterpolatedString(it) => it.syntax(),
            Expression::Literal(it) => it.syntax(),
            Expression::Name(it) => it.syntax(),
            Expression::Block(it) => it.syntax(),
        }
    }
}
