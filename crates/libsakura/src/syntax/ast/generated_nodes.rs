//! Code generated by `cargo xtask codegen`; DO NOT EDIT.

use super::support;
use crate::syntax::ast::{AstChildren, AstNode};
use crate::syntax::{
    SyntaxKind::{self, *},
    SyntaxNode, SyntaxToken,
};
use crate::T;

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct SourceFile {
    pub(crate) syntax: SyntaxNode,
}

impl SourceFile {
    pub fn items(&self) -> AstChildren<Item> {
        support::children(&self.syntax)
    }
}

impl AstNode for SourceFile {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SOURCE_FILE
    }

    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }

    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Item {
    pub(crate) syntax: SyntaxNode,
}

impl Item {
    pub fn type_definition(&self) -> Option<TypeDefinition> {
        support::child(&self.syntax)
    }
}

impl AstNode for Item {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == ITEM
    }

    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }

    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TypeDefinition {
    pub(crate) syntax: SyntaxNode,
}

impl TypeDefinition {
    pub fn type_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!["type"])
    }

    pub fn name(&self) -> Option<Name> {
        support::child(&self.syntax)
    }

    pub fn equal_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!["="])
    }

    pub fn body(&self) -> Option<Type> {
        support::child(&self.syntax)
    }
}

impl AstNode for TypeDefinition {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == TYPE_DEFINITION
    }

    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }

    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Name {
    pub(crate) syntax: SyntaxNode,
}

impl Name {
    pub fn identifier_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!["identifier"])
    }
}

impl AstNode for Name {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == NAME
    }

    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }

    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct StructType {
    pub(crate) syntax: SyntaxNode,
}

impl StructType {
    pub fn struct_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!["struct"])
    }

    pub fn body(&self) -> Option<StructFieldDefinitionList> {
        support::child(&self.syntax)
    }
}

impl AstNode for StructType {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == STRUCT_TYPE
    }

    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }

    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct EnumType {
    pub(crate) syntax: SyntaxNode,
}

impl EnumType {
    pub fn enum_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!["enum"])
    }

    pub fn enum_variant_list(&self) -> Option<EnumVariantList> {
        support::child(&self.syntax)
    }
}

impl AstNode for EnumType {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == ENUM_TYPE
    }

    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }

    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TraitType {
    pub(crate) syntax: SyntaxNode,
}

impl TraitType {
    pub fn trait_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!["trait"])
    }

    pub fn left_curly_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!["{"])
    }

    pub fn right_curly_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!["}"])
    }
}

impl AstNode for TraitType {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == TRAIT_TYPE
    }

    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }

    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TypeList {
    pub(crate) syntax: SyntaxNode,
}

impl TypeList {
    pub fn types(&self) -> AstChildren<Type> {
        support::children(&self.syntax)
    }
}

impl AstNode for TypeList {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == TYPE_LIST
    }

    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }

    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct StructFieldDefinitionList {
    pub(crate) syntax: SyntaxNode,
}

impl StructFieldDefinitionList {
    pub fn left_curly_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!["{"])
    }

    pub fn fields(&self) -> AstChildren<StructField> {
        support::children(&self.syntax)
    }

    pub fn right_curly_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!["}"])
    }
}

impl AstNode for StructFieldDefinitionList {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == STRUCT_FIELD_DEFINITION_LIST
    }

    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }

    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct StructField {
    pub(crate) syntax: SyntaxNode,
}

impl StructField {
    pub fn name(&self) -> Option<Name> {
        support::child(&self.syntax)
    }

    pub fn colon_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![":"])
    }

    pub fn ty(&self) -> Option<Type> {
        support::child(&self.syntax)
    }
}

impl AstNode for StructField {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == STRUCT_FIELD
    }

    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }

    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct EnumVariantList {
    pub(crate) syntax: SyntaxNode,
}

impl EnumVariantList {
    pub fn left_curly_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!["{"])
    }

    pub fn variants(&self) -> AstChildren<EnumVariant> {
        support::children(&self.syntax)
    }

    pub fn right_curly_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!["}"])
    }
}

impl AstNode for EnumVariantList {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == ENUM_VARIANT_LIST
    }

    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }

    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct EnumVariant {
    pub(crate) syntax: SyntaxNode,
}

impl EnumVariant {
    pub fn name(&self) -> Option<Name> {
        support::child(&self.syntax)
    }

    pub fn body(&self) -> Option<EnumVariantBody> {
        support::child(&self.syntax)
    }
}

impl AstNode for EnumVariant {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == ENUM_VARIANT
    }

    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }

    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct EnumVariantBodyTypeList {
    pub(crate) syntax: SyntaxNode,
}

impl EnumVariantBodyTypeList {
    pub fn left_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!["("])
    }

    pub fn type_list(&self) -> Option<TypeList> {
        support::child(&self.syntax)
    }

    pub fn right_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![")"])
    }
}

impl AstNode for EnumVariantBodyTypeList {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == ENUM_VARIANT_BODY_TYPE_LIST
    }

    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }

    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct EnumVariantBodyExpr {
    pub(crate) syntax: SyntaxNode,
}

impl EnumVariantBodyExpr {
    pub fn equal_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!["="])
    }
}

impl AstNode for EnumVariantBodyExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == ENUM_VARIANT_BODY_EXPR
    }

    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }

    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct BinaryExpr {
    pub(crate) syntax: SyntaxNode,
}

impl BinaryExpr {}

impl AstNode for BinaryExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == BINARY_EXPR
    }

    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }

    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct InterpolatedString {
    pub(crate) syntax: SyntaxNode,
}

impl InterpolatedString {}

impl AstNode for InterpolatedString {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == INTERPOLATED_STRING
    }

    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }

    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Literal {
    pub(crate) syntax: SyntaxNode,
}

impl Literal {}

impl AstNode for Literal {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == LITERAL
    }

    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }

    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct InterpolatedStringParts {
    pub(crate) syntax: SyntaxNode,
}

impl InterpolatedStringParts {}

impl AstNode for InterpolatedStringParts {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == INTERPOLATED_STRING_PARTS
    }

    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }

    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct InterpolatedStringSlot {
    pub(crate) syntax: SyntaxNode,
}

impl InterpolatedStringSlot {
    pub fn dollar_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!["$"])
    }

    pub fn left_curly_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!["{"])
    }

    pub fn expr(&self) -> Option<Expr> {
        support::child(&self.syntax)
    }

    pub fn right_curly_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!["}"])
    }
}

impl AstNode for InterpolatedStringSlot {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == INTERPOLATED_STRING_SLOT
    }

    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }

    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum Type {
    Name(Name),
    StructType(StructType),
    EnumType(EnumType),
    TraitType(TraitType),
}

impl From<Name> for Type {
    fn from(node: Name) -> Type {
        Type::Name(node)
    }
}

impl From<StructType> for Type {
    fn from(node: StructType) -> Type {
        Type::StructType(node)
    }
}

impl From<EnumType> for Type {
    fn from(node: EnumType) -> Type {
        Type::EnumType(node)
    }
}

impl From<TraitType> for Type {
    fn from(node: TraitType) -> Type {
        Type::TraitType(node)
    }
}

impl AstNode for Type {
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(kind, NAME | STRUCT_TYPE | ENUM_TYPE | TRAIT_TYPE)
    }

    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            NAME => Type::Name(Name { syntax }),
            STRUCT_TYPE => Type::StructType(StructType { syntax }),
            ENUM_TYPE => Type::EnumType(EnumType { syntax }),
            TRAIT_TYPE => Type::TraitType(TraitType { syntax }),
            _ => return None,
        };

        Some(res)
    }

    fn syntax(&self) -> &SyntaxNode {
        match self {
            Type::Name(it) => it.syntax(),
            Type::StructType(it) => it.syntax(),
            Type::EnumType(it) => it.syntax(),
            Type::TraitType(it) => it.syntax(),
        }
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum EnumVariantBody {
    EnumVariantBodyTypeList(EnumVariantBodyTypeList),
    EnumVariantBodyExpr(EnumVariantBodyExpr),
}

impl From<EnumVariantBodyTypeList> for EnumVariantBody {
    fn from(node: EnumVariantBodyTypeList) -> EnumVariantBody {
        EnumVariantBody::EnumVariantBodyTypeList(node)
    }
}

impl From<EnumVariantBodyExpr> for EnumVariantBody {
    fn from(node: EnumVariantBodyExpr) -> EnumVariantBody {
        EnumVariantBody::EnumVariantBodyExpr(node)
    }
}

impl AstNode for EnumVariantBody {
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(kind, ENUM_VARIANT_BODY_TYPE_LIST | ENUM_VARIANT_BODY_EXPR)
    }

    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            ENUM_VARIANT_BODY_TYPE_LIST => {
                EnumVariantBody::EnumVariantBodyTypeList(EnumVariantBodyTypeList { syntax })
            }
            ENUM_VARIANT_BODY_EXPR => {
                EnumVariantBody::EnumVariantBodyExpr(EnumVariantBodyExpr { syntax })
            }
            _ => return None,
        };

        Some(res)
    }

    fn syntax(&self) -> &SyntaxNode {
        match self {
            EnumVariantBody::EnumVariantBodyTypeList(it) => it.syntax(),
            EnumVariantBody::EnumVariantBodyExpr(it) => it.syntax(),
        }
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum Expr {
    BinaryExpr(BinaryExpr),
    InterpolatedString(InterpolatedString),
    Literal(Literal),
    Name(Name),
}

impl From<BinaryExpr> for Expr {
    fn from(node: BinaryExpr) -> Expr {
        Expr::BinaryExpr(node)
    }
}

impl From<InterpolatedString> for Expr {
    fn from(node: InterpolatedString) -> Expr {
        Expr::InterpolatedString(node)
    }
}

impl From<Literal> for Expr {
    fn from(node: Literal) -> Expr {
        Expr::Literal(node)
    }
}

impl From<Name> for Expr {
    fn from(node: Name) -> Expr {
        Expr::Name(node)
    }
}

impl AstNode for Expr {
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(kind, BINARY_EXPR | INTERPOLATED_STRING | LITERAL | NAME)
    }

    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            BINARY_EXPR => Expr::BinaryExpr(BinaryExpr { syntax }),
            INTERPOLATED_STRING => Expr::InterpolatedString(InterpolatedString { syntax }),
            LITERAL => Expr::Literal(Literal { syntax }),
            NAME => Expr::Name(Name { syntax }),
            _ => return None,
        };

        Some(res)
    }

    fn syntax(&self) -> &SyntaxNode {
        match self {
            Expr::BinaryExpr(it) => it.syntax(),
            Expr::InterpolatedString(it) => it.syntax(),
            Expr::Literal(it) => it.syntax(),
            Expr::Name(it) => it.syntax(),
        }
    }
}
